// Base class for all grid managers
class BaseGridManager {
    constructor(gridSelector, preferredColumnOrder = []) {
        this.gridDiv = document.querySelector(gridSelector);
        this.preferredColumnOrder = preferredColumnOrder;
        this.currentMode = null; // "add" | "edit"
        this.modal = null;
        this.tomSelectInstances = {};
        
        this.initializeEventListeners();
    }

    // Abstract methods to be implemented by subclasses
    getEntityName() { throw new Error("Must implement getEntityName()"); }
    getApiUrls() { throw new Error("Must implement getApiUrls()"); }
    getFormElements() { throw new Error("Must implement getFormElements()"); }
    getFormData() { throw new Error("Must implement getFormData()"); }
    validateFormData(formData, isEdit = false) { throw new Error("Must implement validateFormData()"); }

    // Common initialization
    initializeEventListeners() {
        const elements = this.getFormElements();
        
        // Add button
        document.getElementById(elements.addBtn)?.addEventListener("click", () => {
            this.showModal("add");
        });

        // Save button
        document.getElementById(elements.saveBtn)?.addEventListener("click", () => {
            if (this.currentMode === "add") {
                this.handleSaveNew();
            } else if (this.currentMode === "edit") {
                this.handleSaveEdit();
            }
        });

        // Delete confirmation
        document.getElementById("confirmDeleteBtn")?.addEventListener("click", () => {
            this.handleConfirmDelete();
        });
    }

    // Common load method
    async loadData() {
        try {
            const data = await this.fetchData();
            const gridOptions = this.createGridOptions(data);
            this.initializeGrid(gridOptions);
        } catch (error) {
            this.handleError(`Error loading ${this.getEntityName()}s`, error);
        }
    }

    // Common fetch method
    async fetchData() {
        const response = await fetch(this.getApiUrls().getAll, {
            method: 'GET',
            headers: { 'Accept': 'application/json' }
        });

        if (!response.ok) {
            throw new Error(`Failed to fetch ${this.getEntityName()}s: ${response.status}`);
        }

        return await response.json();
    }

    // Common grid options creation
    createGridOptions(data) {
        const hasData = Array.isArray(data) && data.length > 0;
        return {
            rowData: hasData ? data : [],
            columnDefs: hasData ? this.createColumnDefs(data[0]) : [],
            defaultColDef: {
                resizable: true,
                flex: 1,
                minWidth: 100
            },
            getRowId: (params) => params.data.id,
            onCellClicked: this.handleCellClick.bind(this)
        };
    }

    // Common column definitions creation
    createColumnDefs(firstRow) {
        const allKeys = Object.keys(firstRow);
        const orderedKeys = [
            ...this.preferredColumnOrder,
            ...allKeys.filter(key => !this.preferredColumnOrder.includes(key))
        ];

        const columnDefs = orderedKeys.map(key => this.createColumnDef(key));
        columnDefs.push(this.createActionsColumn());
        
        return columnDefs;
    }

    // Common column definition creation
    createColumnDef(key) {
        // Special handling for common field types
        if (key === "users") {
            return {
                field: "users",
                headerName: "USERS",
                valueGetter: (params) => `${params.data.users?.length || 0} user(s)`,
                sortable: true,
                filter: false
            };
        }

        if (key === "is_active") {
            return {
                field: "is_active",
                headerName: "STATUS",
                cellRenderer: (params) => {
                    const isActive = params.value;
                    const statusClass = isActive ? "text-success" : "text-danger";
                    const statusText = isActive ? "Active" : "Inactive";
                    const icon = isActive ? "fas fa-check-circle" : "fas fa-times-circle";
                    return `<span class="${statusClass}"><i class="${icon} me-1"></i>${statusText}</span>`;
                },
                sortable: true,
                filter: false,
                minWidth: 100
            };
        }

        // Allow subclasses to override column definitions
        const customColumnDef = this.getCustomColumnDef(key);
        if (customColumnDef) {
            return customColumnDef;
        }

        // Default column definition
        return {
            field: key,
            headerName: key.replace(/_/g, " ").toUpperCase(),
            sortable: true,
            filter: true,
            resizable: true
        };
    }

    // Override in subclasses for custom column definitions
    getCustomColumnDef(key) {
        return null;
    }

    // Common actions column creation
    createActionsColumn() {
        const actions = this.getActionButtons();
        return {
            headerName: 'Actions',
            field: 'actions',
            minWidth: actions.length * 50,
            cellRenderer: () => `
                <div class="btn-group" role="group">
                    ${actions.map(action => `
                        <button class="btn btn-sm btn-outline-${action.variant}" 
                                title="${action.title}" data-action="${action.action}">
                            <i class="${action.icon}"></i>
                        </button>
                    `).join('')}
                </div>
            `
        };
    }

    // Override in subclasses to define action buttons
    getActionButtons() {
        return [
            { action: 'edit', title: 'Edit', icon: 'fas fa-edit', variant: 'primary' },
            { action: 'delete', title: 'Delete', icon: 'fas fa-trash-alt', variant: 'danger' },
            { action: 'show-users', title: 'Show Users', icon: 'fas fa-user', variant: 'info' }
        ];
    }

    // Common cell click handler
    handleCellClick(params) {
        const button = params.event.target.closest("button");
        if (!button || !button.dataset.action) return;

        const action = button.dataset.action;
        this.handleAction(action, params);
    }

    // Override in subclasses for custom action handling
    handleAction(action, params) {
        const commonActions = {
            'show-users': () => this.showUsers(params.data.users || []),
            'edit': () => this.showModal("edit", params),
            'delete': () => this.showDeleteConfirmation(params)
        };

        const handler = commonActions[action] || this.getCustomActionHandler(action);
        if (handler) {
            handler(params);
        }
    }

    // Override in subclasses for custom actions
    getCustomActionHandler(action) {
        return null;
    }

    // Common users display
    showUsers(users) {
        const usersList = document.getElementById("usersList");
        usersList.innerHTML = "";

        if (users.length === 0) {
            usersList.innerHTML = "<li class='list-group-item text-muted'>No users assigned</li>";
        } else {
            users.forEach(user => {
                const listItem = this.createUserListItem(user);
                usersList.appendChild(listItem);
            });
        }

        const modal = bootstrap.Modal.getOrCreateInstance(
            document.getElementById("showUsersModal")
        );
        modal.show();
    }

    // Common user list item creation
    createUserListItem(user) {
        const li = document.createElement("li");
        li.className = "list-group-item";
        li.innerHTML = `
            <strong>${user.name} ${user.surname}</strong>
            <div><small>${user.email} â€“ ${user.usertype}</small></div>
        `;
        return li;
    }

    // Common modal display
    showModal(mode, params = null) {
        this.currentMode = mode;
        const elements = this.getFormElements();

        if (!this.modal) {
            this.modal = bootstrap.Modal.getOrCreateInstance(
                document.getElementById(elements.modal)
            );
        }

        const form = document.getElementById(elements.form);
        const titleEl = document.getElementById(elements.modalTitle);
        const primaryEl = document.getElementById(elements.saveBtn);

        if (mode === "add") {
            form.reset();
            titleEl.textContent = `Add New ${this.getEntityName()}`;
            primaryEl.innerHTML = `<i class="fas fa-plus me-1"></i> Create ${this.getEntityName()}`;
            this.clearForm();
        } else {
            this.gridDiv.__pendingEdit = {
                id: params.data.id,
                rowData: params.data,
                rowNode: params.node
            };

            titleEl.textContent = `Edit ${this.getEntityName()}`;
            primaryEl.innerHTML = '<i class="fas fa-save me-1"></i> Save Changes';
            this.populateForm(params.data);
        }

        this.modal.show();
    }

    // Override in subclasses for form clearing
    clearForm() {
        // Default implementation does nothing
    }

    // Override in subclasses for form population
    populateForm(data) {
        // Default implementation does nothing
    }

    // Common delete confirmation
    showDeleteConfirmation(params) {
        this.gridDiv.__pendingDelete = {
            id: params.data.id,
            rowNode: params.node
        };

        const modal = bootstrap.Modal.getOrCreateInstance(
            document.getElementById("confirmDeleteModal")
        );
        modal.show();
    }

    // Common save new handler
    async handleSaveNew() {
        const formData = this.getFormData();

        if (!this.validateFormData(formData)) {
            return;
        }

        try {
            const response = await fetch(this.getApiUrls().create, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(formData)
            });

            if (response.ok) {
                const newItem = await response.json();
                const success = this.addNew(newItem);
                
                if (!success) {
                    console.warn(`Failed to add ${this.getEntityName()} to grid, reloading grid data`);
                    await this.loadData();
                }

                this.closeModal();
                this.resetForm();
            } else {
                const errorText = await response.text();
                alert(`Failed to create ${this.getEntityName()}: ` + errorText);
            }
        } catch (error) {
            this.handleError(`Error creating ${this.getEntityName()}`, error);
        }
    }

    // Common save edit handler
    async handleSaveEdit() {
        const pending = this.gridDiv.__pendingEdit;
        if (!pending) return;

        const formData = this.getFormData();

        if (!this.validateFormData(formData, true)) {
            return;
        }

        try {
            const updateUrl = this.getApiUrls().update.replace('PLACEHOLDER', pending.id);
            
            const response = await fetch(updateUrl, {
                method: "PUT",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(formData)
            });

            if (response.ok) {
                const updatedItem = await response.json();
                const updatedData = { ...pending.rowData, ...updatedItem };
                
                // Preserve related data
                this.preserveRelatedData(updatedData, pending.rowData);
                
                this.gridDiv.__agGridInstance.applyTransaction({ update: [updatedData] });
            } else {
                const errorText = await response.text();
                alert(`Failed to update ${this.getEntityName()}: ` + errorText);
            }
        } catch (error) {
            this.handleError(`Error updating ${this.getEntityName()}`, error);
        } finally {
            this.closeModal();
            delete this.gridDiv.__pendingEdit;
        }
    }

    // Override in subclasses to preserve related data
    preserveRelatedData(updatedData, originalData) {
        // Default: preserve users array
        updatedData.users = originalData.users || [];
    }

    // Common delete handler
    async handleConfirmDelete() {
        const pending = this.gridDiv.__pendingDelete;
        if (!pending) return;

        try {
            const deleteUrl = this.getApiUrls().delete.replace('PLACEHOLDER', pending.id);
            
            const response = await fetch(deleteUrl, { method: "DELETE" });

            if (response.status === 204 || response.ok) {
                this.gridDiv.__agGridInstance.applyTransaction({ 
                    remove: [pending.rowNode.data] 
                });
            } else {
                const errorText = await response.text();
                alert("Delete failed: " + errorText);
            }
        } catch (error) {
            this.handleError(`Error deleting ${this.getEntityName()}`, error);
        } finally {
            this.closeModal("confirmDeleteModal");
            delete this.gridDiv.__pendingDelete;
        }
    }

    // Common modal closing
    closeModal(modalId = null) {
        const targetModalId = modalId || this.getFormElements().modal;
        const modal = bootstrap.Modal.getInstance(document.getElementById(targetModalId));
        if (modal) {
            modal.hide();
        }
    }

    // Common form reset
    resetForm() {
        const formElement = document.getElementById(this.getFormElements().form);
        if (formElement) {
            formElement.reset();
        }
        this.clearForm();
    }

    // Common add new item to grid
    addNew(newItem) {
        if (!this.gridDiv.__agGridInstance) {
            console.error("Grid instance not found");
            return false;
        }

        // Initialize arrays that might be needed
        this.initializeNewItemArrays(newItem);

        const currentColumnDefs = this.gridDiv.__agGridInstance.getColumnDefs();
        const isEmptyGrid = !currentColumnDefs || currentColumnDefs.length === 0;

        if (isEmptyGrid) {
            this.reinitializeGridWithData([newItem]);
        } else {
            this.gridDiv.__agGridInstance.applyTransaction({ add: [newItem] });
        }

        return true;
    }

    // Override in subclasses to initialize arrays for new items
    initializeNewItemArrays(newItem) {
        newItem.users = newItem.users || [];
    }

    // Common grid reinitialization
    reinitializeGridWithData(data) {
        const gridOptions = this.createGridOptions(data);
        this.initializeGrid(gridOptions);
    }

    // Common grid initialization
    initializeGrid(gridOptions) {
        if (this.gridDiv.__agGridInstance) {
            this.gridDiv.__agGridInstance.destroy();
        }
        this.gridDiv.__agGridInstance = agGrid.createGrid(this.gridDiv, gridOptions);
    }

    // Common error handling
    handleError(message, error) {
        console.error(message, error);
        alert("Network error - please try again.");
    }
}

// UserRoleManager - simplified
class UserRoleManager extends BaseGridManager {
    constructor() {
        super("#user-roles-grid", ["id", "rolename", "can_create", "can_read", "can_update", "can_delete", "notes", "users"]);
    }

    getEntityName() { return "Role"; }

    getApiUrls() {
        return {
            getAll: "{{ url_for('get_all_user_roles') }}",
            create: "{{ url_for('create_new_user_role') }}",
            update: "{{ url_for('update_existing_user_role', role_id='PLACEHOLDER') }}",
            delete: "{{ url_for('delete_user_role_by_id', role_id='PLACEHOLDER') }}"
        };
    }

    getFormElements() {
        return {
            addBtn: "user-roles-addRoleBtn",
            saveBtn: "user-roles-saveRoleBtn",
            modal: "user-roles-roleModal",
            modalTitle: "user-roles-roleModalTitle",
            form: "user-roles-roleForm"
        };
    }

    getFormData() {
        return {
            rolename: document.getElementById("user-roles-roleName").value.trim(),
            notes: document.getElementById("user-roles-notes").value.trim(),
            can_create: document.getElementById("user-roles-canCreate").checked,
            can_read: document.getElementById("user-roles-canRead").checked,
            can_update: document.getElementById("user-roles-canUpdate").checked,
            can_delete: document.getElementById("user-roles-canDelete").checked
        };
    }

    validateFormData(formData) {
        if (!formData.rolename) {
            alert("Role name is required");
            return false;
        }
        return true;
    }

    populateForm(data) {
        document.getElementById("user-roles-roleName").value = data.rolename || "";
        document.getElementById("user-roles-notes").value = data.notes || "";
        document.getElementById("user-roles-canCreate").checked = !!data.can_create;
        document.getElementById("user-roles-canRead").checked = !!data.can_read;
        document.getElementById("user-roles-canUpdate").checked = !!data.can_update;
        document.getElementById("user-roles-canDelete").checked = !!data.can_delete;
    }

    // Alias for backwards compatibility
    loadRoles() { return this.loadData(); }
}

// UserSkillManager - simplified
class UserSkillManager extends BaseGridManager {
    constructor() {
        super("#user-skills-grid", ["id", "skillname", "skill_level", "notes", "users"]);
    }

    getEntityName() { return "Skill"; }

    getApiUrls() {
        return {
            getAll: "{{ url_for('get_all_user_skills') }}",
            create: "{{ url_for('create_new_user_skill') }}",
            update: "{{ url_for('update_existing_user_skill', skill_id='PLACEHOLDER') }}",
            delete: "{{ url_for('delete_user_skill_by_id', skill_id='PLACEHOLDER') }}"
        };
    }

    getFormElements() {
        return {
            addBtn: "user-skills-addSkillBtn",
            saveBtn: "user-skills-saveSkillBtn",
            modal: "user-skills-skillModal",
            modalTitle: "user-skills-skillModalTitle",
            form: "user-skills-skillForm"
        };
    }

    getFormData() {
        return {
            skillname: document.getElementById("user-skills-skillname").value.trim(),
            skill_level: document.getElementById("user-skills-skilllevel").value,
            notes: document.getElementById("user-skills-notes").value.trim()
        };
    }

    validateFormData(formData) {
        if (!formData.skillname) {
            alert("Skill name is required");
            return false;
        }
        return true;
    }

    populateForm(data) {
        document.getElementById("user-skills-skillname").value = data.skillname || "";
        document.getElementById("user-skills-skilllevel").value = data.skill_level || "";
        document.getElementById("user-skills-notes").value = data.notes || "";
    }

    // Alias for backwards compatibility
    loadSkills() { return this.loadData(); }
}

// UserModuleManager - simplified (read-only)
class UserModuleManager extends BaseGridManager {
    constructor() {
        super("#user-modules-grid", ["id", "title", "description", "users"]);
    }

    getEntityName() { return "Module"; }

    getApiUrls() {
        return {
            getAll: "{{ url_for('get_all_modules') }}"
        };
    }

    getFormElements() {
        return {}; // No form elements for read-only manager
    }

    getFormData() { return {}; }
    validateFormData() { return true; }

    getActionButtons() {
        return [
            { action: 'show-users', title: 'Show Users', icon: 'fas fa-user', variant: 'info' }
        ];
    }

    initializeEventListeners() {
        // No event listeners for read-only manager
    }

    // Alias for backwards compatibility
    loadModules() { return this.loadData(); }
}

// UserManager - extended with Tom Select functionality
class UserManager extends BaseGridManager {
    constructor() {
        super("#users-grid", ["id", "is_active", "username", "name", "surname", "email", "usertype", "title", "roles", "skills", "modules"]);
        this.tomSelectInstances = {
            roles: null,
            skills: null,
            modules: null
        };
    }

    getEntityName() { return "User"; }

    getApiUrls() {
        return {
            getAll: "{{ url_for('get_all_users') }}",
            create: "{{ url_for('create_new_user') }}",
            update: "{{ url_for('update_existing_user', username='PLACEHOLDER') }}",
            delete: "{{ url_for('delete_user_by_username', username='PLACEHOLDER') }}"
        };
    }

    getFormElements() {
        return {
            addBtn: "users-addUserBtn",
            saveBtn: "users-saveUserBtn",
            modal: "users-userModal",
            modalTitle: "users-userModalTitle",
            form: "users-userForm"
        };
    }

    getCustomColumnDef(key) {
        if (key === "roles") {
            return {
                field: "roles",
                headerName: "ROLES",
                valueGetter: (params) => `${params.data.roles?.length || 0} role(s)`,
                sortable: true,
                filter: false,
                minWidth: 120,
                hide: true
            };
        }

        if (key === "skills") {
            return {
                field: "skills",
                headerName: "SKILLS",
                valueGetter: (params) => `${params.data.skills?.length || 0} skill(s)`,
                sortable: true,
                filter: false,
                minWidth: 120,
                hide: true
            };
        }

        if (key === "modules") {
            return {
                field: "modules",
                headerName: "MODULES",
                valueGetter: (params) => `${params.data.modules?.length || 0} module(s)`,
                sortable: true,
                filter: false,
                minWidth: 120,
                hide: true
            };
        }

        return null;
    }

    getActionButtons() {
        return [
            { action: 'edit', title: 'Edit', icon: 'fas fa-edit', variant: 'primary' },
            { action: 'delete', title: 'Delete', icon: 'fas fa-trash-alt', variant: 'danger' },
            { action: 'show-roles', title: 'Show Roles', icon: 'fas fa-user-shield', variant: 'success' },
            { action: 'show-skills', title: 'Show Skills', icon: 'fas fa-hammer', variant: 'warning' },
            { action: 'show-modules', title: 'Show Modules', icon: 'fas fa-gears', variant: 'secondary' }
        ];
    }

    getCustomActionHandler(action) {
        const handlers = {
            'show-roles': (params) => this.showUserRoles(params.data.roles || []),
            'show-skills': (params) => this.showUserSkills(params.data.skills || []),
            'show-modules': (params) => this.showUserModules(params.data.modules || [])
        };
        return handlers[action];
    }

    async showModal(mode, params = null) {
        this.currentMode = mode;
        const elements = this.getFormElements();

        if (!this.modal) {
            this.modal = bootstrap.Modal.getOrCreateInstance(
                document.getElementById(elements.modal)
            );
        }

        // Initialize Tom Select instances
        await this.initializeTomSelects();

        const form = document.getElementById(elements.form);
        const titleEl = document.getElementById(elements.modalTitle);
        const primaryEl = document.getElementById(elements.saveBtn);

        if (mode === "add") {
            form.reset();
            titleEl.textContent = "Add New User";
            primaryEl.innerHTML = '<i class="fas fa-plus me-1"></i> Create User';
            
            this.clearTomSelects();
            document.getElementById("users-password").required = true;
        } else {
            this.gridDiv.__pendingEdit = {
                id: params.data.username, // Use username for users
                rowData: params.data,
                rowNode: params.node
            };

            titleEl.textContent = "Edit User";
            primaryEl.innerHTML = '<i class="fas fa-save me-1"></i> Save Changes';

            this.populateForm(params.data);
            document.getElementById("users-password").required = false;
        }

        this.modal.show();
    }

    async initializeTomSelects() {
        try {
            this.destroyTomSelects();

            const [rolesData, skillsData, modulesData] = await Promise.all([
                this.fetchRoles(),
                this.fetchSkills(),
                this.fetchModules()
            ]);

            this.tomSelectInstances.roles = new TomSelect('#users-roles', {
                plugins: ['remove_button'],
                valueField: 'id',
                labelField: 'rolename',
                searchField: 'rolename',
                options: rolesData,
                create: false,
                placeholder: 'Select roles...'
            });

            this.tomSelectInstances.skills = new TomSelect('#users-skills', {
                plugins: ['remove_button'],
                valueField: 'id',
                labelField: 'skillname',
                searchField: 'skillname',
                options: skillsData,
                create: false,
                placeholder: 'Select skills...'
            });

            this.tomSelectInstances.modules = new TomSelect('#users-modules', {
                plugins: ['remove_button'],
                valueField: 'id',
                labelField: 'title',
                searchField: 'title',
                options: modulesData,
                create: false,
                placeholder: 'Select modules...'
            });

        } catch (error) {
            console.error("Error initializing Tom Select:", error);
        }
    }

    destroyTomSelects() {
        Object.values(this.tomSelectInstances).forEach(instance => {
            if (instance) {
                instance.destroy();
            }
        });
        this.tomSelectInstances = { roles: null, skills: null, modules: null };
    }

    clearTomSelects() {
        Object.values(this.tomSelectInstances).forEach(instance => {
            if (instance) {
                instance.clear();
            }
        });
    }

    async fetchRoles() {
        const response = await fetch("{{ url_for('get_all_user_roles') }}", {
            method: 'GET',
            headers: { 'Accept': 'application/json' }
        });
        if (!response.ok) throw new Error('Failed to fetch roles');
        return await response.json();
    }

    async fetchSkills() {
        const response = await fetch("{{ url_for('get_all_user_skills') }}", {
            method: 'GET',
            headers: { 'Accept': 'application/json' }
        });
        if (!response.ok) throw new Error('Failed to fetch skills');
        return await response.json();
    }

    async fetchModules() {
        const response = await fetch("{{ url_for('get_all_modules') }}", {
            method: 'GET',
            headers: { 'Accept': 'application/json' }
        });
        if (!response.ok) throw new Error('Failed to fetch modules');
        return await response.json();
    }

    populateForm(data) {
        document.getElementById("users-username").value = data.username || "";
        document.getElementById("users-email").value = data.email || "";
        document.getElementById("users-name").value = data.name || "";
        document.getElementById("users-surname").value = data.surname || "";
        document.getElementById("users-usertype").value = data.usertype || "user";
        document.getElementById("users-isActive").checked = !!data.is_active;
        document.getElementById("users-title").value = data.title || "";
        document.getElementById("users-password").value = "";

        this.populateTomSelects(data);
    }

    populateTomSelects(userData) {
        if (userData.roles && this.tomSelectInstances.roles) {
            const roleIds = userData.roles.map(role => role.id.toString());
            this.tomSelectInstances.roles.setValue(roleIds);
        }

        if (userData.skills && this.tomSelectInstances.skills) {
            const skillIds = userData.skills.map(skill => skill.id.toString());
            this.tomSelectInstances.skills.setValue(skillIds);
        }

        if (userData.modules && this.tomSelectInstances.modules) {
            const moduleIds = userData.modules.map(module => module.id.toString());
            this.tomSelectInstances.modules.setValue(moduleIds);
        }
    }

    clearForm() {
        this.clearTomSelects();
    }

    getFormData() {
        const formData = {
            username: document.getElementById("users-username").value.trim(),
            email: document.getElementById("users-email").value.trim(),
            name: document.getElementById("users-name").value.trim(),
            surname: document.getElementById("users-surname").value.trim(),
            usertype: document.getElementById("users-usertype").value,
            is_active: document.getElementById("users-isActive").checked,
            title: document.getElementById("users-title").value.trim()
        };

        const password = document.getElementById("users-password").value;
        if (password) {
            formData.pw = password;
        }

        if (this.tomSelectInstances.roles) {
            formData.role_ids = this.tomSelectInstances.roles.getValue().map(id => parseInt(id));
        }
        if (this.tomSelectInstances.skills) {
            formData.skill_ids = this.tomSelectInstances.skills.getValue().map(id => parseInt(id));
        }
        if (this.tomSelectInstances.modules) {
            formData.module_ids = this.tomSelectInstances.modules.getValue().map(id => parseInt(id));
        }

        return formData;
    }

    validateFormData(formData, isEdit = false) {
        if (!formData.username) {
            alert("Username is required");
            return false;
        }
        if (!formData.email) {
            alert("Email is required");
            return false;
        }